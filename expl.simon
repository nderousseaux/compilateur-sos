

// déjà normalement dans la règle if .. then .., y a aucun gencode
// c'est à dire que tout est fait avant, dans la règle if .. then.. c'est que des complete de goto inconnu (et gestion de .next)
// exact, voire en dessous meme
// moi j'ai pas codé le -eq, mais j'ai codé le <concatenation> '=' <concatenation> de test_instruction,
// dans ça je fait :
    test_instruction
    : concatenation '=' concatenation {
        $$.true = list_creer(nextquad);
        struct quad q = quad_ifeq($1.res, $3.res);
        gencode(q);

        $$.false = list_creer(nextquad);
        struct quad q2 = quad_goto_unknown();
        gencode(q2);
    et je suppose que c'est plus ou moins pareil avec les -eq, -ne etc 
    et donc dans la règle if, il faut compléter le .true (ça tu peux tout de suite le faire), 7

    
    ok si c'est ça le $$.true dans la règle if tu peux le compléter avec un marqueur que tu mets juste avant la <liste-instruction>
    et ensuite le $$.next tu dois y mettre le .false du <test-bloc>, ainsi que le .next de la <liste-instruction>

    après du coup il faut compléter à un moment le $$.next du if, et ça moi je le fais dans la règle pour liste-instructions
    nan, je sais plus pkvite fait
    en fait le .next de ton if tu sais pas forcément où il va, si par exemple t'es en bas d'un while tu vas pas sortir du while
    while machin :
        if ...

        fi
    done
    le next du if remonte à la condition du while parce que t'as potentiellement besoin de savoir ce qu'il 
    y a après mais bon je suis pas 100% sur de cette explication x) 